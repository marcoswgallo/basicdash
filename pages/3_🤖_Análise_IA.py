import streamlit as st
import pandas as pd
import numpy as np
import plotly.express as px
from streamlit_app import DashboardTecnicos
from sklearn.cluster import KMeans
from sklearn.preprocessing import StandardScaler
from sklearn.ensemble import IsolationForest
from prophet import Prophet
from datetime import timedelta

def prever_demanda(dados):
    """Prev√™ a demanda futura de servi√ßos usando s√©ries temporais"""
    st.subheader("üîÆ Previs√£o de Demanda")
    
    try:
        # Agrupa por data e conta servi√ßos
        demanda_diaria = dados.groupby('DATA_TOA')['CONTRATO'].count().reset_index()
        
        # Prepara dados para o Prophet
        df_prophet = demanda_diaria.rename(columns={'DATA_TOA': 'ds', 'CONTRATO': 'y'})
        
        with st.spinner('Treinando modelo de previs√£o...'):
            # Treina modelo
            model = Prophet(daily_seasonality=True)
            model.fit(df_prophet)
            
            # Faz previs√£o para pr√≥ximos 30 dias
            future = model.make_future_dataframe(periods=30)
            forecast = model.predict(future)
        
        # Plota resultados
        col1, col2 = st.columns(2)
        
        with col1:
            # Gr√°fico de previs√£o
            fig = px.line(
                forecast, 
                x='ds', 
                y=['yhat', 'yhat_lower', 'yhat_upper'],
                title='Previs√£o de Demanda - Pr√≥ximos 30 dias',
                labels={
                    'ds': 'Data',
                    'yhat': 'Previs√£o',
                    'yhat_lower': 'Limite Inferior',
                    'yhat_upper': 'Limite Superior'
                }
            )
            st.plotly_chart(fig, use_container_width=True)
        
        with col2:
            # Componentes da previs√£o
            fig = model.plot_components(forecast)
            st.pyplot(fig)
        
        # M√©tricas de previs√£o
        st.write("### M√©tricas de Previs√£o")
        
        col1, col2, col3 = st.columns(3)
        
        with col1:
            media_atual = df_prophet['y'].mean()
            media_prevista = forecast['yhat'].tail(30).mean()
            variacao = ((media_prevista - media_atual) / media_atual) * 100
            
            st.metric(
                "M√©dia Di√°ria Prevista",
                f"{media_prevista:.1f}",
                f"{variacao:+.1f}%"
            )
        
        with col2:
            st.metric(
                "Pico Previsto",
                f"{forecast['yhat'].max():.1f}",
                f"Data: {forecast.loc[forecast['yhat'].idxmax(), 'ds'].strftime('%d/%m/%Y')}"
            )
        
        with col3:
            st.metric(
                "Vale Previsto",
                f"{forecast['yhat'].min():.1f}",
                f"Data: {forecast.loc[forecast['yhat'].idxmin(), 'ds'].strftime('%d/%m/%Y')}"
            )
            
    except Exception as e:
        st.error(f"Erro ao gerar previs√£o: {str(e)}")

def analisar_clusters_tecnicos(dados):
    """Agrupa t√©cnicos em clusters por performance"""
    st.subheader("üéØ An√°lise de Clusters de Performance")
    
    try:
        # Prepara dados dos t√©cnicos
        metricas_tecnicos = dados.groupby('TECNICO').agg({
            'CONTRATO': 'count',
            'VALOR EMPRESA': 'mean',
            'TEMPO_MINUTOS': 'mean',
            'STATUS': lambda x: (x == 'Executado').mean() * 100
        }).reset_index()
        
        # Seleciona features para clustering
        features = ['CONTRATO', 'VALOR EMPRESA', 'TEMPO_MINUTOS', 'STATUS']
        X = metricas_tecnicos[features].values
        
        # Normaliza dados
        scaler = StandardScaler()
        X_scaled = scaler.fit_transform(X)
        
        # Determina n√∫mero ideal de clusters
        inertias = []
        K = range(1, 10)
        for k in K:
            kmeans = KMeans(n_clusters=k)
            kmeans.fit(X_scaled)
            inertias.append(kmeans.inertia_)
        
        # Aplica K-means com n√∫mero ideal de clusters
        n_clusters = 3  # Pode ser ajustado baseado no elbow plot
        kmeans = KMeans(n_clusters=n_clusters)
        clusters = kmeans.fit_predict(X_scaled)
        
        # Adiciona clusters ao dataframe
        metricas_tecnicos['CLUSTER'] = clusters
        
        # Visualiza√ß√µes
        col1, col2 = st.columns(2)
        
        with col1:
            # Scatter plot 3D
            fig = px.scatter_3d(
                metricas_tecnicos,
                x='CONTRATO',
                y='VALOR EMPRESA',
                z='TEMPO_MINUTOS',
                color='CLUSTER',
                hover_data=['TECNICO'],
                title='Clusters de T√©cnicos - Visualiza√ß√£o 3D'
            )
            st.plotly_chart(fig, use_container_width=True)
        
        with col2:
            # Caracter√≠sticas dos clusters
            for i in range(n_clusters):
                st.write(f"### Cluster {i}")
                cluster_data = metricas_tecnicos[metricas_tecnicos['CLUSTER'] == i]
                
                st.write(f"Quantidade de t√©cnicos: {len(cluster_data)}")
                st.write(f"M√©dia de contratos: {cluster_data['CONTRATO'].mean():.1f}")
                st.write(f"Taxa m√©dia de sucesso: {cluster_data['STATUS'].mean():.1f}%")
                
        # Lista t√©cnicos por cluster
        st.write("### Detalhamento dos Clusters")
        for i in range(n_clusters):
            with st.expander(f"Cluster {i}"):
                cluster_data = metricas_tecnicos[metricas_tecnicos['CLUSTER'] == i]
                st.dataframe(cluster_data)
                
    except Exception as e:
        st.error(f"Erro na an√°lise de clusters: {str(e)}")

def detectar_anomalias(dados):
    """Detecta servi√ßos com padr√µes an√¥malos"""
    st.subheader("üîç Detec√ß√£o de Anomalias")
    
    try:
        # Prepara features para detec√ß√£o
        features = ['TEMPO_MINUTOS', 'VALOR EMPRESA']
        X = dados[features].values
        
        # Treina modelo
        iso_forest = IsolationForest(contamination=0.1, random_state=42)
        anomalias = iso_forest.fit_predict(X)
        
        # Adiciona resultado ao dataframe
        dados_anomalias = dados.copy()
        dados_anomalias['ANOMALIA'] = anomalias
        
        # Visualiza√ß√µes
        col1, col2 = st.columns(2)
        
        with col1:
            # Scatter plot de anomalias
            fig = px.scatter(
                dados_anomalias,
                x='TEMPO_MINUTOS',
                y='VALOR EMPRESA',
                color='ANOMALIA',
                title='Detec√ß√£o de Servi√ßos An√¥malos',
                labels={
                    'TEMPO_MINUTOS': 'Tempo (minutos)',
                    'VALOR EMPRESA': 'Valor (R$)',
                    'ANOMALIA': 'Normal / An√¥malo'
                }
            )
            st.plotly_chart(fig, use_container_width=True)
        
        with col2:
            # Estat√≠sticas das anomalias
            total_anomalias = (anomalias == -1).sum()
            taxa_anomalias = (total_anomalias / len(anomalias)) * 100
            
            st.metric("Total de Anomalias", total_anomalias)
            st.metric("Taxa de Anomalias", f"{taxa_anomalias:.1f}%")
            
        # Detalhamento das anomalias
        st.write("### Servi√ßos An√¥malos Detectados")
        anomalos = dados_anomalias[dados_anomalias['ANOMALIA'] == -1]
        st.dataframe(anomalos)
        
    except Exception as e:
        st.error(f"Erro na detec√ß√£o de anomalias: {str(e)}")

def gerar_recomendacoes(dados):
    """Gera recomenda√ß√µes baseadas em padr√µes identificados"""
    st.subheader("üí° Recomenda√ß√µes Inteligentes")
    
    try:
        # An√°lise de padr√µes de sucesso
        dados_sucesso = dados[dados['STATUS'] == 'Executado']
        
        # Melhores hor√°rios
        melhores_horarios = dados_sucesso.groupby('HORA')['CONTRATO'].count()
        pior_horario = melhores_horarios.idxmin()
        melhor_horario = melhores_horarios.idxmax()
        
        # Melhores t√©cnicos
        melhores_tecnicos = dados_sucesso.groupby('TECNICO').agg({
            'CONTRATO': 'count',
            'VALOR EMPRESA': 'mean',
            'TEMPO_MINUTOS': 'mean'
        }).sort_values('CONTRATO', ascending=False)
        
        # Visualiza√ß√µes
        col1, col2 = st.columns(2)
        
        with col1:
            st.write("### Melhores Hor√°rios")
            fig = px.bar(
                melhores_horarios,
                title='Distribui√ß√£o de Sucesso por Hora',
                labels={'value': 'Quantidade de Servi√ßos'}
            )
            st.plotly_chart(fig, use_container_width=True)
            
        with col2:
            st.write("### Melhores T√©cnicos")
            fig = px.bar(
                melhores_tecnicos.head(10),
                y='CONTRATO',
                title='Top 10 T√©cnicos mais Produtivos'
            )
            st.plotly_chart(fig, use_container_width=True)
        
        # Recomenda√ß√µes
        st.write("### Recomenda√ß√µes Baseadas em Dados")
        
        with st.expander("üìä Distribui√ß√£o de Servi√ßos"):
            st.write(f"- Melhor hor√°rio para servi√ßos: {melhor_horario}h")
            st.write(f"- Hor√°rio a evitar: {pior_horario}h")
            st.write(f"- Taxa de sucesso no melhor hor√°rio: {(melhores_horarios.max()/melhores_horarios.sum()*100):.1f}%")
        
        with st.expander("üë®‚Äçüîß Aloca√ß√£o de T√©cnicos"):
            st.write("Top 3 t√©cnicos mais eficientes:")
            for i, (tecnico, dados) in enumerate(melhores_tecnicos.head(3).iterrows(), 1):
                st.write(f"{i}. {tecnico}")
                st.write(f"   - Servi√ßos realizados: {dados['CONTRATO']:.0f}")
                st.write(f"   - Tempo m√©dio: {dados['TEMPO_MINUTOS']:.1f} min")
                st.write(f"   - Valor m√©dio: R$ {dados['VALOR EMPRESA']:.2f}")
        
    except Exception as e:
        st.error(f"Erro ao gerar recomenda√ß√µes: {str(e)}")

def main():
    st.set_page_config(page_title="An√°lise IA", layout="wide")
    
    st.title("ü§ñ An√°lise com Intelig√™ncia Artificial")
    
    dashboard = DashboardTecnicos()
    arquivos = dashboard.listar_arquivos()
    
    if not arquivos:
        st.error("Nenhum arquivo encontrado")
        return
        
    arquivo = arquivos[0]
    
    if dashboard.carregar_dados(arquivo):
        try:
            dados = dashboard.dados.copy()
            
            # Converte datas
            dados['DATA_TOA'] = pd.to_datetime(dados['DATA_TOA'])
            
            # Adiciona coluna de hora
            dados['HORA'] = dados['DATA_TOA'].dt.hour
            
            # Menu de an√°lises
            analise = st.sidebar.selectbox(
                "Escolha a An√°lise",
                ["Previs√£o de Demanda", 
                 "Clusters de Performance",
                 "Detec√ß√£o de Anomalias",
                 "Recomenda√ß√µes"]
            )
            
            if analise == "Previs√£o de Demanda":
                prever_demanda(dados)
            elif analise == "Clusters de Performance":
                analisar_clusters_tecnicos(dados)
            elif analise == "Detec√ß√£o de Anomalias":
                detectar_anomalias(dados)
            else:
                gerar_recomendacoes(dados)
                
        except Exception as e:
            st.error(f"Erro ao processar dados: {str(e)}")
            st.error(f"Colunas dispon√≠veis: {', '.join(dados.columns)}")

if __name__ == "__main__":
    main() 